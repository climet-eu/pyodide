diff --git a/pyodide_http/_core.py b/pyodide_http/_core.py
index 1cb711d..84c4b9f 100644
--- a/pyodide_http/_core.py
+++ b/pyodide_http/_core.py
@@ -2,6 +2,7 @@ import json
 from dataclasses import dataclass, field
 from typing import Optional, Dict
 from email.parser import Parser
+from jupyterlite_cors import cors_status, cors_url
 from pyodide.ffi import to_js
 
 # need to import streaming here so that the web-worker is setup
@@ -72,7 +73,7 @@ def show_streaming_warning():
         )
 
 
-def send(request: Request, stream: bool = False) -> Response:
+def _send(request: Request, stream: bool = False) -> Response:
     if request.params:
         from js import URLSearchParams
 
@@ -128,3 +129,12 @@ def send(request: Request, stream: bool = False) -> Response:
         body = xhr.response.encode("ISO-8859-15")
 
     return Response(status_code=xhr.status, headers=headers, body=body)
+
+
+def send(request: Request, stream: bool = False) -> Response:
+    request.url = cors_url(request.url)
+
+    response = _send(request, stream)
+    response.status_code = cors_status(request.url, response.status_code)
+
+    return response
diff --git a/pyodide_http/_urllib.py b/pyodide_http/_urllib.py
index 639fee4..7111f17 100644
--- a/pyodide_http/_urllib.py
+++ b/pyodide_http/_urllib.py
@@ -35,15 +35,18 @@ def urlopen(url, *args, **kwargs):
     # compressed format) the 'Content-Length' is the compressed length, while the
     # data itself is uncompressed. This will cause problems while decoding our
     # fake response.
-    headers_without_content_length = {
-        k: v for k, v in resp.headers.items() if k != "content-length"
-    }
+    headers_without_content_length = (
+        {k: v for k, v in resp.headers.items() if k != "content-length"}
+        if "content-encoding" in resp.headers.keys()
+        else resp.headers
+    )
     response_data = (
         b"HTTP/1.1 "
         + str(resp.status_code).encode("ascii")
         + b"\n"
         + "\n".join(
-            f"{key}: {value}" for key, value in headers_without_content_length.items()
+            f"{'_'.join(k.title() for k in key.split('_'))}: {value}"
+            for key, value in headers_without_content_length.items()
         ).encode("ascii")
         + b"\n\n"
         + resp.body
