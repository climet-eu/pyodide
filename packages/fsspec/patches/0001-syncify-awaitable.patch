diff --git a/fsspec/asyn.py b/fsspec/asyn.py
index de41839..3895fd2 100644
--- a/fsspec/asyn.py
+++ b/fsspec/asyn.py
@@ -18,7 +18,6 @@ from .spec import AbstractBufferedFile, AbstractFileSystem
 from .utils import glob_translate, is_exception, other_paths
 
 private = re.compile("_[^_]")
-iothread = [None]  # dedicated fsspec IO thread
 loop = [None]  # global event loop for any non-async instance
 _lock = None  # global lock placeholder
 get_running_loop = asyncio.get_running_loop
@@ -43,7 +42,6 @@ def reset_lock():
     """
     global _lock
 
-    iothread[0] = None
     loop[0] = None
     _lock = None
 
@@ -69,40 +67,15 @@ def sync(loop, func, *args, timeout=None, **kwargs):
     >>> fsspec.asyn.sync(fsspec.asyn.get_loop(), func, *args,
                          timeout=timeout, **kwargs)
     """
-    timeout = timeout if timeout else None  # convert 0 or 0.0 to None
-    # NB: if the loop is not running *yet*, it is OK to submit work
-    # and we will wait for it
-    if loop is None or loop.is_closed():
-        raise RuntimeError("Loop is not running")
+    awaitable = func(*args, **kwargs).__await__()
     try:
-        loop0 = asyncio.events.get_running_loop()
-        if loop0 is loop:
-            raise NotImplementedError("Calling sync() from within a running loop")
-    except NotImplementedError:
-        raise
-    except RuntimeError:
-        pass
-    coro = func(*args, **kwargs)
-    result = [None]
-    event = threading.Event()
-    asyncio.run_coroutine_threadsafe(_runner(event, coro, result, timeout), loop)
-    while True:
-        # this loops allows thread to get interrupted
-        if event.wait(1):
-            break
-        if timeout is not None:
-            timeout -= 1
-            if timeout < 0:
-                raise FSTimeoutError
-
-    return_result = result[0]
-    if isinstance(return_result, asyncio.TimeoutError):
-        # suppress asyncio.TimeoutError, raise FSTimeoutError
-        raise FSTimeoutError from return_result
-    elif isinstance(return_result, BaseException):
-        raise return_result
+        next(awaitable)
+    except StopIteration as result:
+        return result.value
+    except Exception as err:
+        raise err
     else:
-        return return_result
+        raise RuntimeError("could not syncify an awaitable")
 
 
 def sync_wrapper(func, obj=None):
@@ -144,10 +117,6 @@ def get_loop():
             if loop[0] is None:
                 with _selector_policy():
                     loop[0] = asyncio.new_event_loop()
-                th = threading.Thread(target=loop[0].run_forever, name="fsspecIO")
-                th.daemon = True
-                th.start()
-                iothread[0] = th
     return loop[0]
 
 
@@ -232,43 +201,7 @@ async def _run_coros_in_chunks(
         If yes, you normally expect smaller batches.
     """
 
-    if batch_size is None:
-        batch_size = _get_batch_size(nofiles=nofiles)
-
-    if batch_size == -1:
-        batch_size = len(coros)
-
-    assert batch_size > 0
-
-    async def _run_coro(coro, i):
-        try:
-            return await asyncio.wait_for(coro, timeout=timeout), i
-        except Exception as e:
-            if not return_exceptions:
-                raise
-            return e, i
-        finally:
-            callback.relative_update(1)
-
-    i = 0
-    n = len(coros)
-    results = [None] * n
-    pending = set()
-
-    while pending or i < n:
-        while len(pending) < batch_size and i < n:
-            pending.add(asyncio.ensure_future(_run_coro(coros[i], i)))
-            i += 1
-
-        if not pending:
-            break
-
-        done, pending = await asyncio.wait(pending, return_when=asyncio.FIRST_COMPLETED)
-        while done:
-            result, k = await done.pop()
-            results[k] = result
-
-    return results
+    return [await c for c in coros]
 
 
 # these methods should be implemented as async by any async-able backend
