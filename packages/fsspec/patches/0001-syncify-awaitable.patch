diff --git a/fsspec/asyn.py b/fsspec/asyn.py
index de41839..01d0479 100644
--- a/fsspec/asyn.py
+++ b/fsspec/asyn.py
@@ -11,6 +11,8 @@ from contextlib import contextmanager
 from glob import has_magic
 from typing import TYPE_CHECKING, Iterable
 
+import pyodide
+
 from .callbacks import DEFAULT_CALLBACK
 from .exceptions import FSTimeoutError
 from .implementations.local import LocalFileSystem, make_path_posix, trailing_sep
@@ -18,7 +20,6 @@ from .spec import AbstractBufferedFile, AbstractFileSystem
 from .utils import glob_translate, is_exception, other_paths
 
 private = re.compile("_[^_]")
-iothread = [None]  # dedicated fsspec IO thread
 loop = [None]  # global event loop for any non-async instance
 _lock = None  # global lock placeholder
 get_running_loop = asyncio.get_running_loop
@@ -43,7 +44,6 @@ def reset_lock():
     """
     global _lock
 
-    iothread[0] = None
     loop[0] = None
     _lock = None
 
@@ -69,40 +69,22 @@ def sync(loop, func, *args, timeout=None, **kwargs):
     >>> fsspec.asyn.sync(fsspec.asyn.get_loop(), func, *args,
                          timeout=timeout, **kwargs)
     """
-    timeout = timeout if timeout else None  # convert 0 or 0.0 to None
-    # NB: if the loop is not running *yet*, it is OK to submit work
-    # and we will wait for it
-    if loop is None or loop.is_closed():
-        raise RuntimeError("Loop is not running")
-    try:
-        loop0 = asyncio.events.get_running_loop()
-        if loop0 is loop:
-            raise NotImplementedError("Calling sync() from within a running loop")
-    except NotImplementedError:
-        raise
-    except RuntimeError:
-        pass
     coro = func(*args, **kwargs)
-    result = [None]
-    event = threading.Event()
-    asyncio.run_coroutine_threadsafe(_runner(event, coro, result, timeout), loop)
-    while True:
-        # this loops allows thread to get interrupted
-        if event.wait(1):
-            break
-        if timeout is not None:
-            timeout -= 1
-            if timeout < 0:
-                raise FSTimeoutError
-
-    return_result = result[0]
-    if isinstance(return_result, asyncio.TimeoutError):
-        # suppress asyncio.TimeoutError, raise FSTimeoutError
-        raise FSTimeoutError from return_result
-    elif isinstance(return_result, BaseException):
-        raise return_result
+
+    # use JSPI if available
+    if pyodide.ffi.can_run_sync():
+        return pyodide.ffi.run_sync(coro)
+
+    # otherwise fall back to polling the awaitable once
+    # and hoping that it resolves immediately
+    try:
+        next(coro.__await__())
+    except StopIteration as result:
+        return result.value
+    except Exception as err:
+        raise err
     else:
-        return return_result
+        raise RuntimeError("could not syncify an awaitable")
 
 
 def sync_wrapper(func, obj=None):
@@ -144,10 +126,6 @@ def get_loop():
             if loop[0] is None:
                 with _selector_policy():
                     loop[0] = asyncio.new_event_loop()
-                th = threading.Thread(target=loop[0].run_forever, name="fsspecIO")
-                th.daemon = True
-                th.start()
-                iothread[0] = th
     return loop[0]
 
 
@@ -232,6 +210,10 @@ async def _run_coros_in_chunks(
         If yes, you normally expect smaller batches.
     """
 
+    # if JSPI is not available, run the coros sequentially
+    if not pyodide.ffi.can_run_sync():
+        return [await c for c in coros]
+
     if batch_size is None:
         batch_size = _get_batch_size(nofiles=nofiles)
 
